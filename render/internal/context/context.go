//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package context ;import (_b "errors";_fde "github.com/unidoc/freetype/truetype";_bg "github.com/doraemonkeys/unipdf/v3/core";_fb "github.com/doraemonkeys/unipdf/v3/internal/cmap";_bc "github.com/doraemonkeys/unipdf/v3/internal/textencoding";_ee "github.com/doraemonkeys/unipdf/v3/internal/transform";
_fbb "github.com/doraemonkeys/unipdf/v3/model";_g "golang.org/x/image/font";_ea "image";_e "image/color";_fd "strings";);func (_ebf *TextState )ProcTm (a ,b ,c ,d ,e ,f float64 ){_ebf .Tm =_ee .NewMatrix (a ,b ,c ,d ,e ,f );_ebf .Tlm =_ebf .Tm .Clone ();};const (TextRenderingModeFill TextRenderingMode =iota ;
TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);func NewTextFontFromPath (filePath string ,size float64 )(*TextFont ,error ){_eg ,_fad :=_fbb .NewPdfFontFromTTFFile (filePath );
if _fad !=nil {return nil ,_fad ;};return NewTextFont (_eg ,size );};type TextRenderingMode int ;type Gradient interface{Pattern ;AddColorStop (_a float64 ,_d _e .Color );};func (_bca *TextFont )CharcodeToRunes (charcode _bc .CharCode )(_bc .CharCode ,[]rune ){_aaa :=[]_bc .CharCode {charcode };
if _bca ._fgb ==nil ||_bca ._fgb ==_bca .Font {return _bca .charcodeToRunesSimple (charcode );};_agb :=_bca ._fgb .CharcodesToUnicode (_aaa );_gba ,_ :=_bca .Font .RunesToCharcodeBytes (_agb );_edb :=_bca .Font .BytesToCharcodes (_gba );_fcb :=charcode ;
if len (_edb )> 0&&_edb [0]!=0{_fcb =_edb [0];};if string (_agb )==string (_fb .MissingCodeRune )&&_bca ._fgb .BaseFont ()==_bca .Font .BaseFont (){return _bca .charcodeToRunesSimple (charcode );};return _fcb ,_agb ;};func (_ac *TextState )ProcTD (tx ,ty float64 ){_ac .Tl =-ty ;
_ac .ProcTd (tx ,ty )};type Context interface{Push ();Pop ();Matrix ()_ee .Matrix ;SetMatrix (_eb _ee .Matrix );Translate (_ae ,_fbe float64 );Scale (_ba ,_c float64 );Rotate (_fg float64 );MoveTo (_cc ,_ed float64 );LineTo (_baa ,_ab float64 );CubicTo (_ga ,_de ,_cf ,_fa ,_bb ,_ca float64 );
QuadraticTo (_cd ,_df ,_fe ,_ge float64 );NewSubPath ();ClosePath ();ClearPath ();Clip ();ClipPreserve ();ResetClip ();LineWidth ()float64 ;SetLineWidth (_geg float64 );SetLineCap (_da LineCap );SetLineJoin (_daf LineJoin );SetDash (_ce ...float64 );SetDashOffset (_cdb float64 );
Fill ();FillPreserve ();Stroke ();StrokePreserve ();SetRGBA (_bab ,_fag ,_cb ,_ec float64 );SetFillRGBA (_bd ,_ecg ,_abe ,_gc float64 );SetFillStyle (_eab Pattern );SetFillRule (_aef FillRule );SetStrokeRGBA (_db ,_fgg ,_ag ,_cfa float64 );SetStrokeStyle (_ccg Pattern );
FillPattern ()Pattern ;StrokePattern ()Pattern ;TextState ()*TextState ;DrawString (_dd string ,_agf _g .Face ,_aa ,_af float64 );MeasureString (_ddd string ,_ede _g .Face )(_aad ,_fef float64 );DrawRectangle (_gd ,_gdb ,_bae ,_cfd float64 );DrawImage (_gcg _ea .Image ,_dbc ,_cdd int );
DrawImageAnchored (_gb _ea .Image ,_eeg ,_cca int ,_gbf ,_bba float64 );Height ()int ;Width ()int ;};const (LineCapRound LineCap =iota ;LineCapButt ;LineCapSquare ;);func (_ad *TextState )Reset (){_ad .Tm =_ee .IdentityMatrix ();_ad .Tlm =_ee .IdentityMatrix ()};
func (_agc *TextFont )charcodeToRunesSimple (_cbd _bc .CharCode )(_bc .CharCode ,[]rune ){_ded :=[]_bc .CharCode {_cbd };if _agc .Font .IsSimple ()&&_agc ._gf !=nil {if _gfd :=_agc ._gf .Index (rune (_cbd ));_gfd > 0{return _cbd ,[]rune {rune (_cbd )};
};};if _agc ._gf !=nil &&!_agc ._gf .HasCmap ()&&_fd .Contains (_agc .Font .Encoder ().String (),"\u0049d\u0065\u006e\u0074\u0069\u0074\u0079-"){if _cef :=_agc ._gf .Index (rune (_cbd ));_cef > 0{return _cbd ,[]rune {rune (_cbd )};};};return _cbd ,_agc .Font .CharcodesToUnicode (_ded );
};type LineCap int ;type TextFont struct{Font *_fbb .PdfFont ;Size float64 ;_gf *_fde .Font ;_fgb *_fbb .PdfFont ;};const (FillRuleWinding FillRule =iota ;FillRuleEvenOdd ;);func (_ebg *TextState )ProcTd (tx ,ty float64 ){_ebg .Tlm .Concat (_ee .TranslationMatrix (tx ,ty ));
_ebg .Tm =_ebg .Tlm .Clone ();};type Pattern interface{ColorAt (_ef ,_be int )_e .Color ;};type LineJoin int ;func (_efd *TextFont )GetCharMetrics (code _bc .CharCode )(float64 ,float64 ,bool ){if _cda ,_abd :=_efd .Font .GetCharMetrics (code );_abd &&_cda .Wx !=0{return _cda .Wx ,_cda .Wy ,_abd ;
};if _efd ._fgb ==nil {return 0,0,false ;};_fab ,_afa :=_efd ._fgb .GetCharMetrics (code );return _fab .Wx ,_fab .Wy ,_afa &&_fab .Wx !=0;};func (_ff *TextFont )BytesToCharcodes (data []byte )[]_bc .CharCode {if _ff ._fgb !=nil {return _ff ._fgb .BytesToCharcodes (data );
};return _ff .Font .BytesToCharcodes (data );};func (_dg *TextState )ProcTj (data []byte ,ctx Context ){_cdae :=_dg .Tf .Size ;_fdd :=_dg .Th /100.0;_dde :=_dg .GlobalScale ;_bdf :=_ee .NewMatrix (_cdae *_fdd ,0,0,_cdae ,0,_dg .Ts );_ebd :=ctx .Matrix ();
_gcf :=_ebd .Clone ().Mult (_dg .Tm .Clone ().Mult (_bdf )).ScalingFactorY ();_dbb :=_dg .Tf .NewFace (_gcf );_bf :=_dg .Tf .BytesToCharcodes (data );for _ ,_gee :=range _bf {_fdg ,_gdbc :=_dg .Tf .CharcodeToRunes (_gee );_fbd :=string (_gdbc );if _fbd =="\u0000"{continue ;
};_dfg :=_ebd .Clone ().Mult (_dg .Tm .Clone ().Mult (_bdf ));_gdg :=_dfg .ScalingFactorY ();_dfg =_dfg .Scale (1/_gdg ,-1/_gdg );if _dg .Tr !=TextRenderingModeInvisible {ctx .SetMatrix (_dfg );ctx .DrawString (_fbd ,_dbb ,0,0);ctx .SetMatrix (_ebd );};
_cg :=0.0;if _fbd =="\u0020"{_cg =_dg .Tw ;};_afd ,_ ,_bdg :=_dg .Tf .GetCharMetrics (_fdg );if _bdg {_afd =_afd *0.001*_cdae ;}else {_afd ,_ =ctx .MeasureString (_fbd ,_dbb );_afd =_afd /_dde ;};_bedc :=(_afd +_dg .Tc +_cg )*_fdd ;_dg .Tm =_dg .Tm .Mult (_ee .TranslationMatrix (_bedc ,0));
};};func (_def *TextState )ProcDQ (data []byte ,aw ,ac float64 ,ctx Context ){_def .Tw =aw ;_def .Tc =ac ;_def .ProcQ (data ,ctx );};const (LineJoinRound LineJoin =iota ;LineJoinBevel ;);func (_bed *TextFont )NewFace (size float64 )_g .Face {return _fde .NewFace (_bed ._gf ,&_fde .Options {Size :size });
};func (_gg *TextFont )WithSize (size float64 ,originalFont *_fbb .PdfFont )*TextFont {return &TextFont {Font :_gg .Font ,Size :size ,_gf :_gg ._gf ,_fgb :originalFont };};func NewTextState ()TextState {return TextState {Th :100,Tm :_ee .IdentityMatrix (),Tlm :_ee .IdentityMatrix ()};
};func (_gfg *TextState )ProcTf (font *TextFont ){_gfg .Tf =font };func NewTextFont (font *_fbb .PdfFont ,size float64 )(*TextFont ,error ){_aab :=font .FontDescriptor ();if _aab ==nil {return nil ,_b .New ("\u0063\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069pt\u006f\u0072");
};_gaf ,_aabc :=_bg .GetStream (_aab .FontFile2 );if !_aabc {return nil ,_b .New ("\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020f\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_fc ,_efc :=_bg .DecodeStream (_gaf );
if _efc !=nil {return nil ,_efc ;};_bda ,_efc :=_fde .Parse (_fc );if _efc !=nil {return nil ,_efc ;};_cae :=font .FontDescriptor ().FontName .String ();_cdbd :=len (_cae )> 7&&_cae [6]=='+';if !_bda .HasCmap ()&&(!_fd .Contains (font .Encoder ().String (),"\u0049d\u0065\u006e\u0074\u0069\u0074\u0079-")||!_cdbd ){return nil ,_b .New ("\u006e\u006f c\u006d\u0061\u0070 \u0061\u006e\u0064\u0020enc\u006fdi\u006e\u0067\u0020\u0069\u0073\u0020\u006eot\u0020\u0069\u0064\u0065\u006e\u0074\u0069t\u0079");
};return &TextFont {Font :font ,Size :size ,_gf :_bda },nil ;};func (_ege *TextState )ProcTStar (){_ege .ProcTd (0,-_ege .Tl )};type TextState struct{Tc float64 ;Tw float64 ;Th float64 ;Tl float64 ;Tf *TextFont ;Ts float64 ;Tm _ee .Matrix ;Tlm _ee .Matrix ;
Tr TextRenderingMode ;GlobalScale float64 ;};func (_ggd *TextState )Translate (tx ,ty float64 ){_ggd .Tm =_ggd .Tm .Mult (_ee .TranslationMatrix (tx ,ty ));};func (_ggf *TextState )ProcQ (data []byte ,ctx Context ){_ggf .ProcTStar ();_ggf .ProcTj (data ,ctx )};
type FillRule int ;